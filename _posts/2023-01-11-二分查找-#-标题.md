---
layout:     post   				    # 使用的布局（不需要改）
title:      二分查找				# 标题 
subtitle:   关于代码随想录学习Day1 #副标题
date:       2023-01-11 				# 时间
author:     DouglasHao						# 作者
header-img: img/35mqOKArsT.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
---

# 代码随想录Day1|704. 二分查找，27. 移除元素

## 704. 二分查找

题目链接：[704. 二分查找](https://leetcode.cn/problems/binary-search/)

文章链接：[代码随想录](https://programmercarl.com/0704.二分查找.html)

视频讲解：[bilibili](https://www.bilibili.com/video/BV1fA4y1o715)

### 题目：

​		给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

### 示例1：

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

### 示例2：

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### Tips：

```
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
```

## 讲解：

### 	法一（target闭区间[left,right]）：

- - - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
    - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  		![](https://cdn.staticaly.com/gh/ElaborateBury/Net-Imagine@master/Imagine/无标题-2023-01-11-1738.4679kdzyxcm0.webp)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left<=right){ // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = (left+right)/2;
            if (nums[middle] < target){
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            }
            else if(nums[middle] > target){
                right = middle - 1 ; // target 在左区间，所以[left, middle - 1]
            }
            else{ // nums[middle] == target
                return middle;
            }
        }
        return -1;
    }
} 
```

### 法二（target开区间[left,right)||（left,right]）:

- - - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的

    - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

      ![](https://cdn.staticaly.com/gh/ElaborateBury/Net-Imagine@master/Imagine/无标题-2023-01-11-1738(2).6cuawejoijo0.webp)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right){ // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
                int middle = (left + right)/2;
                if (nums[middle]<target){
                    left = middle + 1; // target 在右区间，在[middle + 1, right)中
                }
                else if (nums[middle]>target){
                    right = middle; // target 在左区间，在[left, middle)中
                }
                else{ // nums[middle] == target
                    return middle;
                }
        }
        return -1;
    }
};
```

## 27. 移除元素

题目链接：[27. 移除元素](https://leetcode.cn/problems/remove-element/)

文章链接：[代码随想录](https://programmercarl.com/0027.移除元素.html)

视频讲解：[bilibili](https://www.bilibili.com/video/BV12A4y1Z7LP)

### 题目：

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

### 示例1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

### 示例2:

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素
```

## 讲解：

### 	暴力法：

​					暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

![](https://cdn.staticaly.com/gh/ElaborateBury/Net-Imagine@master/Imagine/27.36vemf71hi80.gif)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
       int size = nums.size();
       for (int i = 0;i < size;i++){
           if (nums[i] == val){
               for (int j = i+1; j < size;j++){
                   nums[j-1] = nums[j]; // 移位
               }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
           }
           
       }
       return size;     
    }
};
```

### 双指针法：

​		双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。定义快慢指针

- - - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
    - 慢指针：指向更新 新数组下标的位置

![](https://cdn.staticaly.com/gh/ElaborateBury/Net-Imagine@master/Imagine/27.50wti5x38ak0.gif)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        int size = nums.size();
        for (int fast = 0; fast < size; fast++){
            if (val != nums[fast]){
                nums[slow] = nums[fast];//可改为 nums[slowIndex++] = nums[fastIndex];
                slow++;
            }
        }
        return slow;
    }
};
```

#### 相向双指针方法（未研究过！）

```c++
/**
* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素
* 时间复杂度：O(n)
* 空间复杂度：O(1)
*/
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while (leftIndex <= rightIndex) {
            // 找左边等于val的元素
            while (leftIndex <= rightIndex && nums[leftIndex] != val){
                ++leftIndex;
            }
            // 找右边不等于val的元素
            while (leftIndex <= rightIndex && nums[rightIndex] == val) {
                -- rightIndex;
            }
            // 将右边不等于val的元素覆盖左边等于val的元素
            if (leftIndex < rightIndex) {
                nums[leftIndex++] = nums[rightIndex--];
            }
        }
        return leftIndex;   // leftIndex一定指向了最终数组末尾的下一个元素
    }
};
```

